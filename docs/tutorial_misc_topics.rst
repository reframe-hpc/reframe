==================================
 Tutorial 3: Miscellaneous topics
==================================

This page collects several smaller tutorials that show specific parts of ReFrame.
They all use the configuration file presented in :doc:`tutorial_basics`, which you can find in ``tutorials/config/settings.py``.
They also assumes that the reader is already familiar with the concepts presented in the basic tutorial.


Testing a CUDA Code
-------------------

In this example, we will create a regression test for a simple CUDA matrix-vector multiplication kernel.

.. literalinclude:: ../tutorials/misc/gpu/cuda.py
   :lines: 6-
   :emphasize-lines: 9,11,13

There are three new things to notice in this test.
First, we restrict the list of valid systems only to the hybrid partition of Piz Daint, since we require GPU nodes.
Second, we set the :attr:`sourcepath` to the CUDA source file as we would do with any other C, C++ or Fortran file.
ReFrame will recognize the ``.cu`` extension of the source file and it will try to invoke ``nvcc`` for compiling the code.
Finally, we define the :attr:`modules <reframe.core.pipeline.RegressionTest.modules>` attribute.
This is essentially a list of environment modules that need to be loaded for running the test.
In this case and in this particular system, we need to load the ``cudatoolkit`` module, which will make available the CUDA SDK.


More On Building Tests
----------------------

We have already seen how ReFrame can compile a test with a single source file.
However, ReFrame can also build tests that use Make or a configure-Make approach.
We are going to demonstrate this through a simple C++ program that computes a dot-product of two vectors and is being compiled through a Makefile.
Additionally, we can select the type of elements for the vectors at compilation time.
Here is the C++ program:

.. literalinclude:: ../tutorials/misc/makefiles/src/dotprod.cpp
   :language: cpp
   :lines: 6-

The directory structure for this test is the following:

.. code-block:: none

   tutorials/makefiles/
   ├── maketest.py
   └── src
       ├── Makefile
       └── dotprod.cpp


Let's have a look at the test itself:

.. literalinclude:: ../tutorials/misc/makefiles/maketest.py
   :lines: 6-22
   :emphasize-lines: 11,13-14

First, if you're using any build system other than ``SingleSource``, you must set the :attr:`executable` attribute of the test, because ReFrame cannot know what is the actual executable to be run.
We then set the build system to :class:`Make <reframe.core.buildsystems.Make>` and set the preprocessor flags as we would do with the :class:`SingleSource` build system.

Let's inspect the build script generated by ReFrame:

.. code-block:: console

   cat output/catalina/default/clang/MakefileTest_float/rfm_MakefileTest_build.sh

.. code-block:: bash

   #!/bin/bash

   _onerror()
   {
       exitcode=$?
       echo "-reframe: command \`$BASH_COMMAND' failed (exit code: $exitcode)"
       exit $exitcode
   }

   trap _onerror ERR

   make -j 1 CPPFLAGS="-DELEM_TYPE=float"


The compiler variables (``CC``, ``CXX`` etc.) are set based on the corresponding values specified in the `coniguration <config_reference.html#environment-configuration>`__ of the current environment.
We can instruct the build system to ignore the default values from the environment by setting its :attr:`flags_from_environ <reframe.core.buildsystems.Make.flags_from_environ>` attribute to false:

.. code-block:: python

  self.build_system.flags_from_environ = False

In this case, ``make`` will be invoked as follows:

.. code::

  make -j 1 CPPFLAGS="-DELEM_TYPE=float"

Notice that the ``-j 1`` option is always generated.
We can increase the build concurrency by setting the :attr:`max_concurrency <reframe.core.buildsystems.Make.max_concurrency>` attribute.
Finally, we may even use a custom Makefile by setting the :attr:`Make <reframe.core.buildsystems.Make.makefile>` attribute:

.. code-block:: python

  self.build_system.max_concurrency = 4
  self.build_system.makefile = 'Makefile_custom'


As a final note, as with the :class:`SingleSource` build system, it wouldn't have been necessary to specify one in this test, if we wouldn't have to set the CPPFLAGS.
ReFrame could automatically figure out the correct build system if :attr:`sourcepath <reframe.core.pipeline.RegressionTest.sourcepath>` refers to a directory.
ReFrame will inspect the directory and it will first try to determine whether this is a CMake or Autotools-based project.
If not, as in this case, it would fall back to the :class:`Make` build system.

More details on ReFrame's build systems can be found `here <regression_test_api.html#build-systems>`__.


Retrieving the source code from a Git repository
================================================

It might be the case that a regression test needs to clone its source code from a remote repository.
This can be achieved in two ways with ReFrame.
One way is to set the :attr:`sourcesdir` attribute to :class:`None` and explicitly clone a repository using the :attr:`prebuild_cmds <reframe.core.pipeline.RegressionTest.prebuild_cmds>`:

.. code-block:: python

   self.sourcesdir = None
   self.prebuild_cmds = ['git clone https://github.com/me/myrepo .']

Alternatively, we can retrieve specifically a Git repository by assigning its URL directly to the :attr:`sourcesdir` attribute:

.. code-block:: python

   self.sourcesdir = 'https://github.com/me/myrepo'

ReFrame will attempt to clone this repository inside the stage directory by executing ``git clone <repo> .`` and will then procede with the build procedure as usual.

.. note::
   ReFrame recognizes only URLs in the :attr:`sourcesdir` attribute and requires passwordless access to the repository.
   This means that the SCP-style repository specification will not be accepted.
   You will have to specify it as URL using the ``ssh://`` protocol (see `Git documentation page <https://git-scm.com/docs/git-clone#_git_urls>`__).


Adding a configuration step before compiling the code
=====================================================

It is often the case that a configuration step is needed before compiling a code with ``make``.
To address this kind of projects, ReFrame aims to offer specific abstractions for "configure-make" style of build systems.
It supports `CMake-based <https://cmake.org/>`__ projects through the :class:`CMake <reframe.core.buildsystems.CMake>` build system, as well as `Autotools-based <https://www.gnu.org/software/automake/>`__ projects through the :class:`Autotools <reframe.core.buildsystems.Autotools>` build system.

For other build systems, you can achieve the same effect using the :class:`Make <reframe.core.buildsystems.Make>` build system and the :attr:`prebuild_cmds <reframe.core.pipeline.RegressionTest.prebuild_cmds>` for performing the configuration step.
The following code snippet will configure a code with ``./custom_configure`` before invoking ``make``:

.. code-block:: python

  self.prebuild_cmds = ['./custom_configure -with-mylib']
  self.build_system = 'Make'
  self.build_system.cppflags = ['-DHAVE_FOO']
  self.build_system.flags_from_environ = False

The generated build script will then have the following lines:

.. code-block:: bash

  ./custom_configure -with-mylib
  make -j 1 CPPFLAGS='-DHAVE_FOO'


Writing a Run-Only Regression Test
----------------------------------

There are cases when it is desirable to perform regression testing for an already built executable.
In the following test we use simply the ``echo`` Bash shell command to print a random integer between specific lower and upper bounds:
Here is the full regression test:

.. literalinclude:: ../tutorials/misc/runonly/echorand.py
   :lines: 6-
   :emphasize-lines: 6

There is nothing special for this test compared to those presented so far except that it derives from the :class:`RunOnlyRegressionTest <reframe.core.pipeline.RunOnlyRegressionTest>`.
Run-only regression tests may also have resources, as for instance a pre-compiled executable or some input data.
These resources may reside under the ``src/`` directory or under any directory specified in the :attr:`sourcesdir <reframe.core.pipeline.RegressionTest.sourcesdir>` attribute.
These resources will be copied to the stage directory at the beginning of the run phase.


Writing a Compile-Only Regression Test
--------------------------------------

ReFrame provides the option to write compile-only tests which consist only of a compilation phase without a specified executable.
This kind of tests must derive from the :class:`CompileOnlyRegressionTest <reframe.core.pipeline.CompileOnlyRegressionTest>` class provided by the framework.
The following test is a compile-only version of the :class:`MakefileTest` presented `previously <#more-on-building-tests>`__ which checks that no warnings are issued by the compiler:

.. literalinclude:: ../tutorials/misc/makefiles/maketest.py
   :lines: 25-33
   :emphasize-lines: 2

What is worth noting here is that the standard output and standard error of the test, which are accessible through the :attr:`stdout <reframe.core.pipeline.RegressionTest.stdout>` and :attr:`stderr <reframe.core.pipeline.RegressionTest.stderr>` attributes, correspond now to the standard output and error of the compilation command.
Therefore sanity checking can be done in exactly the same way as with a normal test.


Applying a Sanity Function Iteratively
--------------------------------------

It is often the case that a common sanity pattern has to be applied many times.
The following script prints 100 random integers between the limits given by the environment variables ``LOWER`` and ``UPPER``.

.. literalinclude:: ../tutorials/misc/random/src/random_numbers.sh
  :language: bash
  :lines: 7-

In the corresponding regression test we want to check that all the random numbers generated lie between the two limits, which means that a common sanity check has to be applied to all the printed random numbers.
Here is the corresponding regression test:

.. literalinclude:: ../tutorials/misc/random/randint.py
  :lines: 6-
  :emphasize-lines: 12-

First, we extract all the generated random numbers from the output.
What we want to do is to apply iteratively the :func:`assert_bounded <reframe.utility.sanity.assert_bounded>` sanity function for each number.
The problem here is that we cannot simply iterate over the ``numbers`` list, because that would trigger prematurely the evaluation of the :func:`extractall <reframe.utility.sanity.extractall>`.
We want to defer also the iteration.
This can be achieved by using the :func:`map() <reframe.utility.sanity.map>` ReFrame sanity function, which is a replacement of Python's built-in :py:func:`map` function and does exactly what we want: it applies a function on all the elements of an iterable and returns another iterable with the transformed elements.
Passing the result of the :py:func:`map` function to the :func:`all <reframe.utility.sanity.all>` sanity function ensures that all the elements lie between the desired bounds.

There is still a small complication that needs to be addressed.
As a direct replacement of the built-in :py:func:`all` function, ReFrame's :func:`all() <reframe.utility.sanity.all>` sanity function returns :class:`True` for empty iterables, which is not what we want.
So we must make sure that all 100 numbers are generated.
This is achieved by the ``sn.assert_eq(sn.count(numbers), 100)`` statement, which uses the :func:`count() <reframe.utility.sanity.count>` sanity function for counting the generated numbers.
Finally, we need to combine these two conditions to a single deferred expression that will be assigned to the test's :attr:`sanity_patterns`.
As with the :keyword:`for` loop discussed above, we cannot defer the evaluation of the :keyword:`and` operator, so we use ReFrame's the :func:`and_() <reframe.utility.sanity.and_>` sanity function to accomplish this.

For more information about how exactly sanity functions work and how their execution is deferred, please refer to :doc:`deferrables`.

.. note::
   .. versionadded:: 2.13
      ReFrame offers also the :func:`allx() <reframe.utility.sanity.allx>` sanity function which, conversely to the builtin :func:`all()` function, will return :class:`False` if its iterable argument is empty.


Customizing the Test Job Script
-------------------------------

It is often the case that we need to run some commands before or after the parallel launch of our executable.
This can be easily achieved by using the :attr:`prerun_cmds <reframe.core.pipeline.RegressionTest.prerun_cmds>` and :attr:`postrun_cmds <reframe.core.pipeline.RegressionTest.postrun_cmds>` attributes of a ReFrame test.

The following example is a slightly modified version of the random numbers test presented `above <#applying-a-sanity-function-iteratively>`__.
The lower and upper limits for the random numbers are now set inside a helper shell script in ``limits.sh`` located in the test's resources, which we need to source before running our tests.
Additionally, we want also to print ``FINISHED`` after our executable has finished.
Here is the modified test file:

.. literalinclude:: ../tutorials/misc/random/prepostrun.py
   :lines: 6-
   :emphasize-lines: 11-12,17,20-21

The :attr:`prerun_cmds` and :attr:`postrun_cmds` are lists of commands to be emitted in the generated job script before and after the parallel launch of the executable.
Obviously, the working directory for these commands is that of the job script itself, which is the stage directory of the test.
The generated job script for this test looks like the following:

.. code-block:: console

   cat output/catalina/default/gnu/PrepostRunTest/rfm_PrepostRunTest_job.sh

.. code-block:: bash

   #!/bin/bash
   source limits.sh
    ./random_numbers.sh
   echo FINISHED

Generally, ReFrame generates the job shell scripts using the following pattern:

.. code-block:: bash

   #!/bin/bash -l
   {job_scheduler_preamble}
   {test_environment}
   {prerun_cmds}
   {parallel_launcher} {executable} {executable_opts}
   {postrun_cmds}

The ``job_scheduler_preamble`` contains the backend job scheduler directives that control the job allocation.
The ``test_environment`` are the necessary commands for setting up the environment of the test.
These include any modules or environment variables set at the `system partition level <config_reference.html#system-partition-configuration>`__ or any `modules <regression_test_api.html#reframe.core.pipeline.RegressionTest.modules>`__ or `environment variables <regression_test_api.html#reframe.core.pipeline.RegressionTest.variables>`__ set at the test level.
Then the commands specified in :attr:`prerun_cmds <reframe.core.pipeline.RegressionTest.prerun_cmds>` follow, while those specified in the :attr:`postrun_cmds <reframe.core.pipeline.RegressionTest.postrun_cmds>` come after the launch of the parallel job.
The parallel launch itself consists of three parts:

#. The parallel launcher program (e.g., ``srun``, ``mpirun`` etc.) with its options,
#. the regression test executable as specified in the :attr:`executable <reframe.core.pipeline.RegressionTest.executable>` attribute and
#. the options to be passed to the executable as specified in the :attr:`executable_opts <reframe.core.pipeline.RegressionTest.executable_opts>` attribute.


Flexible Regression Tests
-------------------------

.. versionadded:: 2.15

ReFrame can automatically set the number of tasks of a particular test, if its :attr:`num_tasks <reframe.core.pipeline.RegressionTest.num_tasks>` attribute is set to a negative value or zero.
In ReFrame's terminology, such tests are called *flexible*.
Negative values indicate the minimum number of tasks that are acceptable for this test (a value of ``-4`` indicates that at least ``4`` tasks are required).
A zero value indicates the default minimum number of tasks which is equal to :attr:`num_tasks_per_node <reframe.core.pipeline.RegressionTest.num_tasks_per_node>`.

By default, ReFrame will spawn such a test on all the idle nodes of the current system partition, but this behavior can be adjusted with the |--flex-alloc-nodes|_ command-line option.
Flexible tests are very useful for diagnostics tests, e.g., tests for checking the health of a whole set nodes.
In this example, we demonstrate this feature through a simple test that runs ``hostname``.
The test will verify that all the nodes print the expected host name:

.. literalinclude:: ../tutorials/misc/flexnodes/flextest.py
   :lines: 6-
   :emphasize-lines: 11-16

The first thing to notice in this test is that :attr:`num_tasks <reframe.core.pipeline.RegressionTest.num_tasks>` is set to zero.
This is a requirement for flexible tests.
The sanity check of this test simply counts the host names printed and verifies that they are as many as expected.
Notice, however, that the sanity check does not use :attr:`num_tasks` directly, but rather access the attribute through the :func:`sn.getattr() <reframe.utility.sanity.getattr>` sanity function, which is a replacement for the :func:`getattr` builtin.
The reason for that is that at the time the sanity check expression is created, :attr:`num_tasks` is ``0`` and it will only be set to its actual value during the run phase.
Consequently, we need to defer the attribute retrieval, thus we use the :func:`sn.getattr() <reframe.utility.sanity.getattr>` sanity function instead of accessing it directly


.. |--flex-alloc-nodes| replace:: :attr:`--flex-alloc-nodes`
.. _--flex-alloc-nodes: manpage.html#cmdoption-flex-alloc-nodes



Testing containerized applications
----------------------------------

.. versionadded:: 2.20


ReFrame can be used also to test applications that run inside a container.
First, we need to enable the container platform support in ReFrame's configuration and, specifically, at the partition configuration level:

.. literalinclude:: ../tutorials/config/settings.py
   :lines: 40-54
   :emphasize-lines: 8-13

For each partition, users can define a list of container platforms supported using the :js:attr:`container_platforms` configuration parameter.
In this case, we define the `Singularity <https://sylabs.io>`__ platform, for which we set the :js:attr:`modules` parameter in order to instruct ReFrame to load the ``singularity`` module, whenever it needs to run with this container platform.

The following test will use a Singularity container to run:

.. literalinclude:: ../tutorials/misc/containers/container_test.py
   :lines: 6-
   :emphasize-lines: 11-16

A container-based test can be written as :class:`RunOnlyRegressionTest <reframe.core.pipeline.RunOnlyRegressionTest>` that sets the :attr:`container_platform <reframe.core.pipeline.RegressionTest.container_platform>` attribute.
This attribute accepts a string that corresponds to the name of the container platform that will be used to run the container for this test.
In this case, the test will be using `Singularity <https://sylabs.io>`__ as a container platform.
If such a platform is not `configured <config_reference.html#container-platform-configuration>`__ for the current system, the test will fail.

As soon as the container platform to be used is defined, you need to specify the container image to use and the commands to run inside the container by setting the :attr:`image <reframe.core.containers.ContainerPlatform.image>` and the :attr:`commands <reframe.core.containers.ContainerPlatform.commands>` container platform attributes.
These two attributes are mandatory for container-based checks.
It is important to note that the :attr:`executable <reframe.core.pipeline.RegressionTest.executable>` and :attr:`executable_opts <reframe.core.pipeline.RegressionTest.executable_opts>` attributes of the actual test are ignored in case of container-based tests.

ReFrame will run the container as follows:

.. code-block:: console

    singularity exec -B"/path/to/test/stagedir:/workdir" docker://ubuntu:18.04 bash -c 'cd rfm_workdir; pwd; ls; cat /etc/os-release'

By default ReFrame will mount the stage directory of the test under ``/rfm_workdir`` inside the container and it will always prepend a ``cd`` command to that directory.
The user commands are then run from that directory one after the other.
Once the commands are executed, the container is stopped and ReFrame goes on with the sanity and performance checks.
Users may also change the default mount point of the stage directory by using :attr:`workdir <reframe.core.pipeline.RegressionTest.container_platform.workdir>` attribute:
Besides the stage directory, additional mount points can be specified through the :attr:`mount_points <reframe.core.pipeline.RegressionTest.container_platform.mount_points>` attribute:

.. code-block:: python

    self.container_platform.mount_points = [('/path/to/host/dir1', '/path/to/container/mount_point1'),
                                            ('/path/to/host/dir2', '/path/to/container/mount_point2')]

For a complete list of the available attributes of a specific container platform, please have a look at the :ref:`container-platforms` section of the :doc:`regression_test_api` guide.
On how to configure ReFrame for running containerized tests, please have a look at the :ref:`container-platform-configuration` section of the :doc:`config_reference`.
